import UIKit

/*:
 # きょうの作業ログ　2020/08/16
 
 ・プログラムを弄って変えている間に、「どうすれば全体的な振る舞いを維持したまま構造を変えていけるか」みたいな学びがある。

 新しい構造を導入しても、それが機能しきるまではブリッジを残し続けるとか。
 
 */

let multidimenssionArray = [[1,2,3],[4],[5,6,7,8,9]]
print(multidimenssionArray.flatMap { $0 })

/*:
 ・https://ja.wikipedia.org/wiki/木構造_(データ構造)
 
 ・Tree構造はOnordered Tree(順序なし木)とOrdered Tree(順序つき木)があるが、普通に実装するとリストを使った順序付き木になる。
 
 ・木構造の実装はいくつかあり
 - 各ノードが子ノードへのポインタのリストを持つ
 - 各ノードが親ノードへのポインタを持つ
 - 各ノードが親ノードへのポインタと子ノードへのポインタのリストを持つ
 - 各ノードが長男ノードへのポインタと弟ノードへのポインタを持つ
 など、他にも配列を使った実装などがある。
 
 ・Traverseとは走査のことで、木構造になる全ノードを一回ずつ体型的に調査する処理である。配列の走査は、通常前から順番に行われるが、木構造のトラバースはいくつか走査法の種類がある。
 
 - 深さ優先探索
 - 幅優先探索
 - 糸付き2分木
 
 そして順序にもpre-order, in-order, post-orderがある。
 
 ・深さ優先探索では、左のノードが走査対象かリーフになるまで探索し、右の探索に移る。
 ・幅優先探索では、同じ深度のノードを左から右に走査していく。深度ベース探索
 
 ・各ノードが親と子へのポインタを持っているタイプの実装だと、子が親を入れ替えた時に、親の子への参照を更新する、グラフマネジメントが結構面倒なので、どちらか片方の方が実装が楽(だと思う)
 
 */

class Node {
    var parent: Node? // nilのときは、それがルートノード
}

// swiftの値型で再帰を記述したいときは、indirectが必要らしい。再帰構造の値型だと、インスタンスに必要なサイズが決まらないので通常ダメだが、indirectにする事で参照になるっぽい。(具体的な話はよく分かってない)
enum EnumNode {
    case leaf
    indirect case node([EnumNode])
    indirect case root([EnumNode])
}

/*:
 ・計算量の勉強をしている。これまで勉強不足だったので必要に応じて、今やっているので食えるようになったら、CSをきっちりやる。今まさに必要性を感じていて、力不足も感じる。
 ただ、直近必要な分野以外に投資する余地が残っていないので、年末イメージ。
 https://atcoder.jp/contests/apg4b/tasks/APG4b_w
 
「プログラムの実行に必要な計算のステップ数が入力に対してどのように変化するか」という指標を時間計算量という。
「プログラムの実行に必要なメモリの量が入力に対してどのように変化するか」を空間計算量という。
 
 単に計算量と言うときは、時間計算量をさす。計算量の表記にはオーダー記法(O)を利用する。(これは知ってた)
 
 ・基本的にはオーダー記法で計算量を考えて良いが(オーダーが増えるたびに顕著に違いが出るので)、オーダー数が等しい場合は無視した係数や低い次数の影響が出る。
 ・より計算量を最適化したい場合は、その辺りがメインになってくる。
 
 ・うーん。実装難しい。グラフ理論を先に学んだ方が良いのか。まぁそれは後にしよう。
 */
