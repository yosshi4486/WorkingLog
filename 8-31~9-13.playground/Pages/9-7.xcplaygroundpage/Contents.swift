//: [Previous](@previous)

/*:
 # きょうの作業ログ　2020/09/07
 ・再帰呼び出しって遅いのでは？と思ったので調べている。
 ・https://engineering.mercari.com/blog/entry/2019-12-16-081047/
 ・コールスタックが関数の呼び出し情報を格納するスタックで、スタックフレームがそのスタックに格納される情報の単位。再帰呼び出しをすると、コールスタックに再帰の数だけのスタックフレームを初期化してpushする。
 ・これに関しては、ある一定の条件下においてはコンパイラの最適化によって、再帰処理がループと等価の処理に置き換えられる。
 ・この条件を末尾再帰という
 */

// 末尾再帰ではない再帰関数
func powerA(_ base: Int, _ exponent: Int) -> Int {
    if exponent == 0 {
        return 1
    } else if exponent == 1 {
        return base
    }
    return base * powerA(base, exponent-1)
}

powerA(2, 0)
powerA(2, 1)
powerA(2, 2)
powerA(2, 3)
powerA(2, 4)

// 上記の関数を10万回ぐらい再帰させるとスタックオーバーフローになるかも(マシン性能による)

// 末尾再帰
func powerB(_ base: Int, _ exponent: Int, _ res: Int = 1) -> Int {
    
    if exponent == 0 {
        return res
    }

    return powerB(base, exponent-1, res*base)
}
powerB(2, 0)
powerB(2, 1)
powerB(2, 2)
powerB(2, 3)
powerB(2, 4)

/*:
 このように、末尾再帰(と、コンパイラの最適化オプションの有効)を条件としてコールスタックへのスタックフレームのpushをループと等価の処理に置き換える処理を、**末尾再帰除去**と言い、それを用いた最適化を**末尾再帰除去最適化**という。
 ・今日はグラフ理論の二分グラフの章を終えて、やっと木の章に入れた。木の定義が「サイクルがなく連結したグラフ」だとすると、木構造でよくあるsiblingへのポインタとか、rootへのポインタとか、糸付き二分木とか、b+treeもそうだけど、それってサイクルとは違うのかな？という疑問がある。サイクルがあるなら木ではないのでは？
 ・@inlinableは、再帰呼び出しでなくても関数をぴょんぴょん呼び出す処理だとスタックフレーム初期化とpushが増えるので、呼び出し部分に直接実装を埋め込むようにコンパイラに指示を出して実行時のオーバーヘッドを殺す。という目的のものだと考えた。
 ・@usableFromInlineは、そのインライン関数から呼び出される関数である。というマークなので、呼び出し元に対してusableFromInlineを付けた関数も一緒に実装が埋め込まれるのではないだろうか。(名前がちゃんと付けられていると、挙動を推論できて良い)
 ・
 */
//: [Next](@next)
